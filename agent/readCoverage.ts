import fs from "fs"
import path from "path"

/**
 * Metadata for a branch in the source code.
 */
interface BranchMeta {
    line: number
    type: string
}

/**
 * An entry for a specific file in the coverage report.
 */
interface CoverageEntry {
    path: string
    s: Record<string, number> // Statement coverage counts
    b: Record<string, number[]> // Branch coverage counts
    branchMap: Record<string, BranchMeta> // Mapping of branches to source lines
}

/**
 * The structure of the final coverage JSON report generated by Vitest.
 */
type CoverageReport = Record<string, CoverageEntry>

/**
 * Result of the coverage analysis for a specific file.
 */
export interface CoverageResult {
    percentage: number
    uncoveredBranchLines: number[]
}

/**
 * Reads the coverage report from disk and extracts details for a specific file.
 * 
 * @param sourceFilePath - The path of the source file to analyze.
 * @returns An object containing the coverage percentage and a list of uncovered branch lines.
 * @throws Error if the coverage report file is missing.
 */
export function getFileCoverageDetails(
    sourceFilePath: string
): CoverageResult {
    // Vitest (via v8) generates this file when running with --coverage
    const coveragePath = path.resolve(
        "coverage/coverage-final.json"
    )

    if (!fs.existsSync(coveragePath)) {
        throw new Error("Coverage report not found")
    }

    const raw = JSON.parse(
        fs.readFileSync(coveragePath, "utf-8")
    ) as CoverageReport

    // Find the coverage entry that matches our source file
    const entry = Object.values(raw).find((item) =>
        item.path.endsWith(sourceFilePath)
    )

    if (!entry) {
        // Return 0% coverage if the file is not found in the report
        return { percentage: 0, uncoveredBranchLines: [] }
    }

    // Extract all statement coverage hit counts
    const statementValues = Object.values(entry.s)
    // Extract all branch coverage hit counts (each branch can have multiple conditions)
    const branchEntries = Object.entries(entry.b)
    const branchValues = branchEntries.flatMap(
        ([, counts]) => counts
    )

    // Calculate total number of trackable items (statements + branches)
    const total =
        statementValues.length + branchValues.length

    // Count how many of those items were actually executed
    const covered =
        statementValues.filter((c) => c > 0).length +
        branchValues.filter((c) => c > 0).length

    const uncoveredBranchLines: number[] = []

    // Map any uncovered branch back to its original line number in the source file
    branchEntries.forEach(([key, counts]) => {
        const hasUncovered = counts.some((c) => c === 0)

        if (hasUncovered) {
            const meta = entry.branchMap[key]
            if (meta?.line) {
                uncoveredBranchLines.push(meta.line)
            }
        }
    })

    // Compute the final percentage
    const percentage =
        total === 0 ? 100 : Math.round((covered / total) * 100)

    return {
        percentage,
        uncoveredBranchLines,
    }
}
